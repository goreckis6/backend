#!/usr/bin/env python3
"""
Optimized CSV to MOBI Converter
Handles large files with pagination and streaming
"""

import sys
import os
import pandas as pd
import argparse
from pathlib import Path
from jinja2 import Template
import tempfile
import subprocess

def escape_html(text):
    """Escape HTML special characters"""
    if not isinstance(text, str):
        text = str(text)
    return (text.replace('&', '&amp;')
                .replace('<', '&lt;')
                .replace('>', '&gt;')
                .replace('"', '&quot;')
                .replace("'", '&#39;'))

def create_optimized_html_template():
    """Create optimized HTML template for large CSV files"""
    return Template("""
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>{{ title }}</title>
    <meta name="author" content="{{ author }}">
    <meta name="generator" content="Morphy Converter">
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
            line-height: 1.4;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 4px solid #007bff;
        }
        .stats {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .stat-item {
            background: #e9ecef;
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: bold;
        }
        .chapter {
            page-break-before: always;
            margin-top: 40px;
        }
        .chapter:first-child {
            page-break-before: auto;
        }
        h2 {
            color: #007bff;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        table { 
            border-collapse: collapse; 
            width: 100%; 
            margin: 20px 0;
            font-size: 12px;
        }
        th, td { 
            border: 1px solid #ddd; 
            padding: 6px 4px; 
            text-align: left; 
            vertical-align: top;
        }
        th { 
            background-color: #f2f2f2; 
            font-weight: bold;
            color: #333;
            font-size: 11px;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .toc {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        .toc h2 {
            margin-top: 0;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        .toc li {
            margin: 5px 0;
        }
        .toc a {
            text-decoration: none;
            color: #007bff;
        }
        .toc a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>{{ title }}</h1>
        <p><strong>Author:</strong> {{ author }}</p>
        <p><strong>Generated by:</strong> Morphy Converter</p>
        <p><strong>Date:</strong> {{ date }}</p>
        <div class="stats">
            <div class="stat-item">Total Rows: {{ total_rows }}</div>
            <div class="stat-item">Columns: {{ col_count }}</div>
            <div class="stat-item">Chapters: {{ chapter_count }}</div>
            <div class="stat-item">File Size: {{ file_size }}</div>
        </div>
    </div>
    
    <div class="toc">
        <h2>Table of Contents</h2>
        <ul>
            {% for chapter in chapters %}
            <li><a href="#chapter{{ loop.index }}">Chapter {{ loop.index }}: {{ chapter.title }} ({{ chapter.rows }} rows)</a></li>
            {% endfor %}
        </ul>
    </div>
    
    {% for chapter in chapters %}
    <div class="chapter" id="chapter{{ loop.index }}">
        <h2>{{ chapter.title }}</h2>
        <p><em>Rows {{ chapter.start_row + 1 }} to {{ chapter.end_row }} of {{ total_rows }}</em></p>
        <table>
            <thead>
                <tr>
                    {% for column in columns %}
                    <th>{{ column }}</th>
                    {% endfor %}
                </tr>
            </thead>
            <tbody>
                {% for row in chapter.data %}
                <tr>
                    {% for cell in row %}
                    <td>{{ cell }}</td>
                    {% endfor %}
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
    {% endfor %}
</body>
</html>
""")

def create_mobi_from_csv_optimized(csv_file, output_file, title="CSV Data", author="Unknown", rows_per_chapter=1000):
    """Convert CSV to MOBI with pagination for large files"""
    try:
        print(f"Reading CSV file: {csv_file}")
        
        # Read CSV in chunks to handle large files
        chunk_size = 5000
        df_chunks = []
        total_rows = 0
        
        for chunk in pd.read_csv(csv_file, chunksize=chunk_size):
            df_chunks.append(chunk)
            total_rows += len(chunk)
            print(f"Processed {total_rows} rows so far...")
        
        # Combine chunks
        df = pd.concat(df_chunks, ignore_index=True)
        print(f"Total rows: {len(df)}, Columns: {len(df.columns)}")
        
        # Get columns
        columns = df.columns.tolist()
        
        # Create chapters for large datasets
        chapters = []
        num_chapters = (len(df) + rows_per_chapter - 1) // rows_per_chapter
        
        print(f"Creating {num_chapters} chapters with {rows_per_chapter} rows each")
        
        for i in range(num_chapters):
            start_row = i * rows_per_chapter
            end_row = min(start_row + rows_per_chapter, len(df))
            chapter_data = df.iloc[start_row:end_row]
            
            chapters.append({
                'title': f'Data Section {i + 1}',
                'data': chapter_data.values.tolist(),
                'start_row': start_row,
                'end_row': end_row - 1,
                'rows': len(chapter_data)
            })
            
            print(f"Created chapter {i + 1}/{num_chapters} (rows {start_row}-{end_row-1})")
        
        # Generate HTML
        template = create_optimized_html_template()
        html_content = template.render(
            title=title,
            author=author,
            date=pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S'),
            total_rows=len(df),
            col_count=len(columns),
            chapter_count=num_chapters,
            file_size=f"{os.path.getsize(csv_file) / 1024 / 1024:.1f} MB",
            columns=columns,
            chapters=chapters
        )
        
        # Write HTML file
        html_file = output_file.replace('.mobi', '.html')
        with open(html_file, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        print(f"Generated HTML: {html_file} ({len(html_content)} characters)")
        
        # Convert HTML to MOBI using Calibre with optimized settings
        calibre_cmd = [
            'ebook-convert',
            html_file,
            output_file,
            '--output-profile=kindle',
            '--disable-font-rescaling',
            '--title', title,
            '--authors', author,
            '--no-default-epub-cover',
            '--disable-dehyphenate',
            '--enable-heuristics',
            '--pretty-print'
        ]
        
        print(f"Converting to MOBI with Calibre...")
        print(f"Command: {' '.join(calibre_cmd)}")
        
        result = subprocess.run(calibre_cmd, capture_output=True, text=True, timeout=300)
        
        if result.returncode != 0:
            print(f"Calibre error: {result.stderr}")
            return False, f"Calibre conversion failed: {result.stderr}"
        
        print(f"Successfully created MOBI: {output_file}")
        
        # Clean up HTML file
        try:
            os.remove(html_file)
        except:
            pass
        
        return True, f"Successfully converted to MOBI: {len(df)} rows, {len(columns)} columns, {num_chapters} chapters"
        
    except subprocess.TimeoutExpired:
        return False, "Conversion timed out - file too large"
    except Exception as e:
        print(f"Error creating MOBI: {str(e)}")
        return False, f"Error converting to MOBI: {str(e)}"

def main():
    parser = argparse.ArgumentParser(description='Convert CSV to MOBI (optimized for large files)')
    parser.add_argument('csv_file', help='Input CSV file')
    parser.add_argument('output_file', help='Output MOBI file')
    parser.add_argument('--title', default='CSV Data', help='Document title')
    parser.add_argument('--author', default='Unknown', help='Document author')
    parser.add_argument('--rows-per-chapter', type=int, default=1000, help='Rows per chapter')
    
    args = parser.parse_args()
    
    print(f"Converting {args.csv_file} to {args.output_file}")
    print(f"Title: {args.title}, Author: {args.author}")
    print(f"Rows per chapter: {args.rows_per_chapter}")
    
    success, message = create_mobi_from_csv_optimized(
        args.csv_file,
        args.output_file,
        args.title,
        args.author,
        args.rows_per_chapter
    )
    
    if success:
        print(f"SUCCESS: {message}")
        sys.exit(0)
    else:
        print(f"ERROR: {message}")
        sys.exit(1)

if __name__ == "__main__":
    main()
