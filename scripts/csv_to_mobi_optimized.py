#!/usr/bin/env python3
"""
Optimized CSV to MOBI Converter
Handles large files with pagination and streaming
"""

import sys
import os
import pandas as pd
import argparse
from pathlib import Path
from jinja2 import Template
import tempfile
import subprocess
from datetime import datetime

def escape_html(text):
    """Escape HTML special characters"""
    if not isinstance(text, str):
        text = str(text)
    return (text.replace('&', '&amp;')
                .replace('<', '&lt;')
                .replace('>', '&gt;')
                .replace('"', '&quot;')
                .replace("'", '&#39;'))

def create_optimized_html_template():
    """Create optimized HTML template for large CSV files"""
    return Template("""
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>{{ title }}</title>
    <meta name="author" content="{{ author }}">
    <meta name="generator" content="Morphy Converter">
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
            line-height: 1.4;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 4px solid #007bff;
        }
        .stats {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .stat-item {
            background: #e9ecef;
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: bold;
        }
        .chapter {
            page-break-before: always;
            margin-top: 40px;
        }
        .chapter:first-child {
            page-break-before: auto;
        }
        h2 {
            color: #007bff;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        table { 
            border-collapse: collapse; 
            width: 100%; 
            margin: 20px 0;
            font-size: 12px;
        }
        th, td { 
            border: 1px solid #ddd; 
            padding: 6px 4px; 
            text-align: left; 
            vertical-align: top;
        }
        th { 
            background-color: #f2f2f2; 
            font-weight: bold;
            color: #333;
            font-size: 11px;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .toc {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        .toc h2 {
            margin-top: 0;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        .toc li {
            margin: 5px 0;
        }
        .toc a {
            text-decoration: none;
            color: #007bff;
        }
        .toc a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>{{ title }}</h1>
        <p><strong>Author:</strong> {{ author }}</p>
        <p><strong>Generated by:</strong> Morphy Converter</p>
        <p><strong>Date:</strong> {{ date }}</p>
        <div class="stats">
            <div class="stat-item">Total Rows: {{ total_rows }}</div>
            <div class="stat-item">Columns: {{ col_count }}</div>
            <div class="stat-item">Chapters: {{ chapter_count }}</div>
            <div class="stat-item">File Size: {{ file_size }}</div>
        </div>
    </div>
    
    <div class="toc">
        <h2>Table of Contents</h2>
        <ul>
            {% for chapter in chapters %}
            <li><a href="#chapter{{ loop.index }}">Chapter {{ loop.index }}: {{ chapter.title }} ({{ chapter.rows }} rows)</a></li>
            {% endfor %}
        </ul>
    </div>
    
    {% for chapter in chapters %}
    <div class="chapter" id="chapter{{ loop.index }}">
        <h2>{{ chapter.title }}</h2>
        <p><em>Rows {{ chapter.start_row + 1 }} to {{ chapter.end_row }} of {{ total_rows }}</em></p>
        <table>
            <thead>
                <tr>
                    {% for column in columns %}
                    <th>{{ column }}</th>
                    {% endfor %}
                </tr>
            </thead>
            <tbody>
                {% for row in chapter.data %}
                <tr>
                    {% for cell in row %}
                    <td>{{ cell }}</td>
                    {% endfor %}
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
    {% endfor %}
</body>
</html>
""")

def create_mobi_from_csv_optimized(csv_file, output_file, title="CSV Data", author="Unknown", rows_per_chapter=1000):
    """Convert CSV to MOBI with pagination for large files"""
    try:
        print(f"Reading CSV file: {csv_file}")
        
        # Check if file exists and is readable
        if not os.path.exists(csv_file):
            return False, f"Input file does not exist: {csv_file}"
        
        if not os.access(csv_file, os.R_OK):
            return False, f"Input file is not readable: {csv_file}"
        
        # Read CSV in chunks to handle large files
        chunk_size = 5000
        df_chunks = []
        total_rows = 0
        
        try:
            for chunk in pd.read_csv(csv_file, chunksize=chunk_size):
                df_chunks.append(chunk)
                total_rows += len(chunk)
                print(f"Processed {total_rows} rows so far...")
        except Exception as e:
            return False, f"Failed to read CSV file: {str(e)}"
        
        if not df_chunks:
            return False, "No data found in CSV file"
        
        # Combine chunks
        try:
            df = pd.concat(df_chunks, ignore_index=True)
            print(f"Total rows: {len(df)}, Columns: {len(df.columns)}")
        except Exception as e:
            return False, f"Failed to combine CSV chunks: {str(e)}"
        
        # Get columns
        columns = df.columns.tolist()
        
        # Create chapters for large datasets
        chapters = []
        num_chapters = (len(df) + rows_per_chapter - 1) // rows_per_chapter
        
        print(f"Creating {num_chapters} chapters with {rows_per_chapter} rows each")
        
        for i in range(num_chapters):
            start_row = i * rows_per_chapter
            end_row = min(start_row + rows_per_chapter, len(df))
            chapter_data = df.iloc[start_row:end_row]
            
            chapters.append({
                'title': f'Data Section {i + 1}',
                'data': chapter_data.values.tolist(),
                'start_row': start_row,
                'end_row': end_row - 1,
                'rows': len(chapter_data)
            })
            
            print(f"Created chapter {i + 1}/{num_chapters} (rows {start_row}-{end_row-1})")
        
        # Generate HTML
        template = create_optimized_html_template()
        html_content = template.render(
            title=title,
            author=author,
            date=datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            total_rows=len(df),
            col_count=len(columns),
            chapter_count=num_chapters,
            file_size=f"{os.path.getsize(csv_file) / 1024 / 1024:.1f} MB",
            columns=columns,
            chapters=chapters
        )
        
        # Write HTML file
        html_file = output_file.replace('.mobi', '.html')
        with open(html_file, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        print(f"Generated HTML: {html_file} ({len(html_content)} characters)")
        
        # Convert HTML to MOBI using Calibre with multiple fallback options
        calibre_commands = [
            # Try with minimal options first
            [
                'ebook-convert',
                html_file,
                output_file,
                '--title', title,
                '--authors', author
            ],
            # Try with kindle profile
            [
                'ebook-convert',
                html_file,
                output_file,
                '--output-profile=kindle',
                '--title', title,
                '--authors', author
            ],
            # Try with additional options
            [
                'ebook-convert',
                html_file,
                output_file,
                '--output-profile=kindle',
                '--disable-font-rescaling',
                '--title', title,
                '--authors', author
            ]
        ]
        
        print(f"Converting to MOBI with Calibre...")
        
        for i, calibre_cmd in enumerate(calibre_commands):
            print(f"Trying Calibre command {i+1}/{len(calibre_commands)}: {' '.join(calibre_cmd)}")
            
            try:
                result = subprocess.run(calibre_cmd, capture_output=True, text=True, timeout=300)
                
                if result.returncode == 0:
                    # Check if output file was created
                    if os.path.exists(output_file):
                        output_size = os.path.getsize(output_file)
                        if output_size > 0:
                            print(f"Successfully created MOBI: {output_file} ({output_size} bytes)")
                            break
                        else:
                            print(f"Calibre created empty output file, trying next command...")
                            continue
                    else:
                        print(f"Calibre did not create output file, trying next command...")
                        continue
                else:
                    print(f"Calibre command {i+1} failed: {result.stderr}")
                    if i == len(calibre_commands) - 1:
                        return False, f"All Calibre commands failed. Last error: {result.stderr}"
                    continue
                    
            except subprocess.TimeoutExpired:
                print(f"Calibre command {i+1} timed out, trying next command...")
                if i == len(calibre_commands) - 1:
                    return False, "All Calibre commands timed out after 5 minutes"
                continue
            except Exception as e:
                print(f"Calibre command {i+1} execution failed: {str(e)}")
                if i == len(calibre_commands) - 1:
                    return False, f"All Calibre commands failed. Last error: {str(e)}"
                continue
        else:
            return False, "All Calibre conversion attempts failed"
        
        # Clean up HTML file
        try:
            os.remove(html_file)
        except:
            pass
        
        return True, f"Successfully converted to MOBI: {len(df)} rows, {len(columns)} columns, {num_chapters} chapters"
        
    except subprocess.TimeoutExpired:
        return False, "Conversion timed out - file too large"
    except Exception as e:
        print(f"Error creating MOBI: {str(e)}")
        return False, f"Error converting to MOBI: {str(e)}"

def main():
    try:
        parser = argparse.ArgumentParser(description='Convert CSV to MOBI (optimized for large files)')
        parser.add_argument('csv_file', help='Input CSV file')
        parser.add_argument('output_file', help='Output MOBI file')
        parser.add_argument('--title', default='CSV Data', help='Document title')
        parser.add_argument('--author', default='Unknown', help='Document author')
        parser.add_argument('--rows-per-chapter', type=int, default=1000, help='Rows per chapter')
        
        args = parser.parse_args()
        
        print(f"Converting {args.csv_file} to {args.output_file}")
        print(f"Title: {args.title}, Author: {args.author}")
        print(f"Rows per chapter: {args.rows_per_chapter}")
        
        # Check if input file exists
        if not os.path.exists(args.csv_file):
            print(f"ERROR: Input file does not exist: {args.csv_file}")
            sys.exit(1)
        
        # Check file size
        file_size = os.path.getsize(args.csv_file)
        print(f"Input file size: {file_size / 1024 / 1024:.2f} MB")
        
        success, message = create_mobi_from_csv_optimized(
            args.csv_file,
            args.output_file,
            args.title,
            args.author,
            args.rows_per_chapter
        )
        
        if success:
            print(f"SUCCESS: {message}")
            sys.exit(0)
        else:
            print(f"ERROR: {message}")
            sys.exit(1)
            
    except Exception as e:
        print(f"FATAL ERROR: {str(e)}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
